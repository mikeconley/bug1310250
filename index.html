<!DOCTYPE html>
<html>
<head>
<base href="https://mikeconley.github.io/bug1310250/">
<title> Tab Spinners - Bug 1310250</title>
<script src="https://telemetry.mozilla.org/v2/telemetry.js"></script>

<!-- MG.js stuff -->
<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="metricsgraphics.min.js"></script>
<link href="metricsgraphics.css" rel="stylesheet" type="text/css">

<style>
.plot-container {
  height: 30vh;
  width: 95vw;
}

.severity {
  height: 40vh;
}

.centered {
  padding-top: 1em;
  border-top: 1px solid #999999;
  text-align: center;
}

#branch_selector {
  font-size: 1.0em;
  padding-right: 25px;
}

</style>
</head>
<body>
<h1>
<select id="branch_selector">
  <option value="nightly">Nightly</option>
  <option value="aurora">Aurora</option>
</select> 51+, Windows only</h1>

<div id="affected" class="plot-container">
</div>
<div id="long-severity" class="plot-container severity">
</div>
<div id="long-severity-legend"></div>
<div id="short-severity" class="plot-container severity">
</div>
<div id="short-severity-legend"></div>

<p class="centered">
  The graphs below do not line up exactly, date-wise, with the graphs above.
</p>

<div id="proportions" class="plot-container">
</div>
<div id="times" class="plot-container">
</div>
<div id="spinners" class="plot-container">
</div>
<div id="switches" class="plot-container">
</div>


<div id="notes">
<p><b>Notes:</b></p>
<ul>
<li>Spinner counts, durations are from FX_TAB_SWITCH_SPINNER_VISIBLE_MS</li>
<li>Switch counts, durations are from FX_TAB_SWITCH_TOTAL_E10S_MS</li>
<li>Only clients with e10s on are considered</li>
<li>These plots start at Nightly 51 and continue to present day, on Nightly</li>
<li>The severity percentages represent how many users fell into that bucket as their worst spinner</li>
</ul>
</div>
<script>
const TAB_SPINNER = "FX_TAB_SWITCH_SPINNER_VISIBLE_MS";
const TAB_SWITCH = "FX_TAB_SWITCH_TOTAL_E10S_MS";

const NIGHTLY_MARKERS = [{
  "date": new Date("2016-09-17T00:00:00.000Z"),
  "label": "Unknown regression :(" // Bug 1321373
}, {
  "date": new Date("2016-09-18T00:00:00.000Z"),
  "label": "Interrupt JS added"
}, {
  "date": new Date("2016-10-11T00:00:00.000Z"),
  "label": "Interrupt GC added"
}, {
  "date": new Date("2016-10-14T00:00:00.000Z"),
  "label": "ForcePaint BHR"
}, {
  "date": new Date("2016-10-20T00:00:00.000Z"),
  "label": "a11y on Win" // Bug 1310788
}, {
  "date": new Date("2016-11-06T00:00:00.000Z"),
  "label": "GPU process aggravates perma-spinner bug"
}, {
  "date": new Date("2016-11-29T00:00:00.000Z"),
  "label": "Perma-spinner fixed" // Bug 1316632
}, {
  "date": new Date("2016-12-18T00:00:00.000Z"),
  "label": "Paint Supr. fixed" // Bug 1323586
}, {
  "date": new Date("2016-12-19T00:00:00.000Z"),
  "label": "Updates frozen"
}, {
  "date": new Date("2016-12-22T00:00:00.000Z"),
  "label": "Updates thawed" // Bug 1325115
}, {
  "date": new Date("2017-01-05T00:00:00.000Z"),
  "label": "First activate" // Bug 1323319
}, {
  "date": new Date("2017-01-19T00:00:00.000Z"),
  "label": "Yield GC backed out" // Bug 1328423
}, {
  "date": new Date("2017-01-25T00:00:00.000Z"),
  "label": "e10s-multi enabled"
}, {
  "date": new Date("2017-02-03T00:00:00.000Z"),
  "label": "mccr8's GC patch" // Bug 1110928
}, {
  "date": new Date("2017-02-08T00:00:00.000Z"),
  "label": "no sync start msgs" // Bug 1303096
}, {
  "date": new Date("2017-02-17T00:00:00.000Z"),
  "label": "no sync layers" // Bug 1328797
}, {
  "date": new Date("2017-03-08T00:00:00.000Z"),
  "label": "No TabChild" // Bug 1342927
}, {
  "date": new Date("2017-03-18T00:00:00.000Z"),
  "label": "Cached content scripts" // Bug 1333990
}, {
  "date": new Date("2017-03-19T00:00:00.000Z"),
  "label": "4 content processes" // Bug 1336398
}, {
  "date": new Date("2017-03-22T00:00:00.000Z"),
  "label": "Async Perms, Child restore" // Bug 1337056, Bug 1256472
}, {
  "date": new Date("2017-04-06T00:00:00.000Z"),
  "label": "Tab move" // Bug 1351677
}, {
  "date": new Date("2017-05-04T00:00:00.000Z"),
  "label": "Preallocator + no shims" // Bug 1341008, Bug 1352204
}, {
  "date": new Date("2017-05-06T00:00:00.000Z"),
  "label": "No tab re-use" // Bug 1054740
}, {
  "date": new Date("2017-05-24T00:00:00.000Z"),
  "label": "Blank" // Bug 1362866
}, {
  "date": new Date("2017-06-02T00:00:00.000Z"),
  "label": "Blank busy" // Bug 1367596
}, {
  "date": new Date("2017-06-11T00:00:00.000Z"),
  "label": "Interrupt reflow" // Bug 1360946
}];

const AURORA_MARKERS = [{
  "date": new Date("2016-12-19T00:00:00.000Z"),
  "label": "Updates frozen"
}, {
  "date": new Date("2016-12-22T00:00:00.000Z"),
  "label": "Updates thawed" // Bug 1325115
}, {
  "date": new Date("2017-01-12T00:00:00.000Z"),
  "label": "Yield GC backed out" // Bug 1328423
}, {
  "date": new Date("2017-01-21T00:00:00.000Z"),
  "label": "First activate" // Bug 1323319
}, {
  "date": new Date("2017-01-24T00:00:00.000Z"),
  "label": "Uplift (53)"
}, {
  "date": new Date("2017-03-10T00:00:00.000Z"),
  "label": "Uplift (54)"
}];

const BRANCHES = {
  'nightly': {
    markers: NIGHTLY_MARKERS,
    severity_url: "https://s3-us-west-2.amazonaws.com/telemetry-public-analysis-2/spinner-severity-generator/data/severities_by_build_id_nightly.json",
  },
  'aurora': {
    markers: AURORA_MARKERS,
    severity_url: "https://s3-us-west-2.amazonaws.com/telemetry-public-analysis-2/spinner-severity-generator/data/severities_by_build_id_aurora.json",
  }
}

let selected_branch = window.location.hash.slice(1);
let branch_data = BRANCHES[selected_branch];

if (!branch_data) {
  console.error("Never heard of branch " + selected_branch + " before - switching to Nightly");
  selected_branch = "nightly";
  branch_data = BRANCHES[selected_branch];
}

let branch_selector = document.getElementById("branch_selector");
branch_selector.value = selected_branch;
branch_selector.addEventListener("change", function onChange(e) {
  if (branch_selector.value != selected_branch) {
    window.location.hash = branch_selector.value;
    window.location.reload();
  }
});

Telemetry.init(() => {
  let rawVersions = Telemetry.getVersions(`${selected_branch}/51`, `${selected_branch}/A`);
  let versions = rawVersions.map(version => version.split("/"));
  let data = {};
  Promise.all(versions.map(([channel, version]) => new Promise((resolve, reject) => {
    Telemetry.getEvolution(channel, version, TAB_SPINNER, {os: ["Windows_NT"], e10sEnabled: "true"}, false /* useSubmissionDate */, evolutionMap => {
      if (!("" in evolutionMap) || !evolutionMap[""] || !evolutionMap[""].sanitized()) {
        console.error(`Failed to get tab spinner data for ${channel}/${version}`);
        //reject();
        resolve();
        return;
      }
      let ev = evolutionMap[""].sanitized();
      ev.map((hgram, i, date) => {
        if (!(date in data)) {
          data[date] = {
            date: date,
            spinners: hgram.count,
            spinnersSum: hgram.sum,
            switches: 0,
            switchesSum: 0,
          };
        } else {
          data[date].spinners += hgram.count;
          data[date].spinnersSum += hgram.sum;
        }
      });

      resolve();
    });
  }))).then(() => {
    Promise.all(versions.map(([channel, version]) => new Promise((resolve, reject) => {
      Telemetry.getEvolution(channel, version, TAB_SWITCH, {e10sEnabled: "true"}, false /* useSubmissionDate */, evolutionMap => {
        if (!("" in evolutionMap) || !evolutionMap[""] || !evolutionMap[""].sanitized()) {
          console.error(`Failed to get tab switch data for ${channel}/${version}`);
          resolve();
          return;
        }
        let ev = evolutionMap[""].sanitized();
        ev.map((hgram, i, date) => {
          if (!(date in data)) {
            data[date] = {
              date: date,
              spinners: 0,
              spinnsersSum: 0,
              switches: hgram.count,
              switchesSum: hgram.sum,
            };
          } else {
            data[date].switches += hgram.count;
            data[date].switchesSum += hgram.sum;
          }
        });

        resolve();
      });
    }))).then(() => {
      let dataArray = Object.keys(data).map(date => {
        return {
          date: new Date(date),
          spinners: data[date].spinners,
          switches: data[date].switches,
          proportions: 1.0 * data[date].spinners / data[date].switches,
          times: 1.0 * data[date].spinnersSum / data[date].switchesSum,
        };
      });
      const PLOT_TITLES = {
        spinners: "Number of Tab Spinners",
        switches: "Number of Tab Switches",
        proportions: "What % of Tab Switches see Spinners?",
        times: "What % of Total Switch time is Spinner time?",
      };
      ['spinners', 'switches', 'proportions', 'times'].forEach(plot => {
        MG.data_graphic({
          title: PLOT_TITLES[plot],
          data: dataArray,
          full_width: true,
          full_height: true,
          show_tooltips: false,
          target: "#" + plot,
          y_accessor: plot,
          format: ['proportions', 'times'].includes(plot) ? 'percentage' : 'count',
          //legend: LINES,
          //legend_target: "#none",
          utc_time: true,
          buffer: 0,
          interpolate: d3.curveLinear,
          markers: branch_data.markers,
        });
      });
    });
  });
});


fetch(branch_data.severity_url).then((response) => {
  return response.json();
}).then((data) => {
  console.log("Got severity data. Converting into something useful...");

  let yyyymmdd_to_date = (yyyymmdd) => {
    let y = yyyymmdd.substr(0,4),
        m = yyyymmdd.substr(4,2) - 1,
        d = yyyymmdd.substr(6,2);
    let D = new Date(y, m, d);
    return (D.getFullYear() == y && D.getMonth() == m && D.getDate() == d) ? D : 'invalid date';
  };

  // First, let's transform the data so that MG can use it for the affected graph.
  let long_data = data["long"];
  let prepared_long_data = long_data.map((element) => {
    let date = yyyymmdd_to_date(element[0]);
    let severities = element[1];
    let affected = 1.0 - severities[0];
    return {
      date,
      affected,
    }
  });

  // The first plot is "affected", so take 1.0, subtract the unaffected, and
  // there you have it.
  MG.data_graphic({
    title: "Affected client %",
    data: prepared_long_data,
    full_width: true,
    full_height: true,
    show_tooltips: false,
    target: "#affected",
    y_accessor: "affected",
    format: "percentage",
    //legend: LINES,
    //legend_target: "#none",
    utc_time: true,
    buffer: 0,
    interpolate: d3.curveLinear,
    markers: branch_data.markers,
  });

  // Now transform the data for our multi-line plot for severities.
  const LONG_LABELS = [
    "unaffected",
    "0ms - 999ms",
    "1000ms - 2296ms",
    "2297ms - 5276ms",
    "5277ms - 12123ms",
    "12124ms - 27855ms",
    "27856ms - 63999ms",
    "64000ms+",
  ];

  let long_severities = [];
  for (let i = 0; i < long_data.length; ++i) {
    let build_data = long_data[i];
    let date = yyyymmdd_to_date(build_data[0]);
    let build_severities = build_data[1];
    for (let j = 0; j < build_severities.length; ++j) {
      if (!long_severities[j]) {
        long_severities[j] = [];
      }

      long_severities[j].push({
        date,
        value: build_severities[j],
      });
    }
  }

  // Now get rid of unaffected, since we don't care about it.
  long_severities.shift();
  let long_legend = LONG_LABELS.concat();
  long_legend.shift();

  MG.data_graphic({
    title: "Long Severity %",
    data: long_severities,
    show_tooltips: false,
    full_width: true,
    full_height: true,
    format: "percentage",
    target: "#long-severity",
    colors: ["green", "blue", "purple", "red", "darkred", "orange", "black"],
    legend: long_legend,
    legend_target: "#long-severity-legend",
    markers: branch_data.markers,
  });

  // Now transform the data for our multi-line plot for severities.
  const SHORT_LABELS = [
    "unaffected",
    "not short",
    "0ms - 49ms",
    "50ms - 99ms",
    "100ms - 199ms",
    "200ms - 399ms",
    "400ms - 799ms",
    "800ms - 999ms",
  ];

  let short_data = data["short"];
  let short_severities = [];
  for (let i = 0; i < short_data.length; ++i) {
    let build_data = short_data[i];
    let date = yyyymmdd_to_date(build_data[0]);
    let build_severities = build_data[1];
    for (let j = 0; j < build_severities.length; ++j) {
      if (!short_severities[j]) {
        short_severities[j] = [];
      }

      short_severities[j].push({
        date,
        value: build_severities[j],
      });
    }
  }

  // Now get rid of unaffected, and not short, since we don't care about
  // them.
  short_severities = short_severities.slice(2);
  let short_legend = SHORT_LABELS.concat().slice(2);

  MG.data_graphic({
    title: "Short Severity %",
    data: short_severities,
    show_tooltips: false,
    full_width: true,
    full_height: true,
    format: "percentage",
    target: "#short-severity",
    colors: ["green", "blue", "purple", "red", "darkred", "orange"],
    legend: short_legend,
    legend_target: "#short-severity-legend",
    markers: branch_data.markers,
  });
});

</script>
</body>
</html>
